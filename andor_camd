#!/usr/bin/env python3.6
#
# This file is part of camd.
#
# camd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# camd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with camd.  If not, see <http://www.gnu.org/licenses/>.

"""Daemon for controlling the Warwick one-metre telescope cameras via Pyro"""

# pylint: disable=too-many-return-statements
# pylint: disable=too-many-branches
# pylint: disable=too-many-instance-attributes

import argparse
from ctypes import c_bool
import datetime
import json
from multiprocessing import Process, Queue, Value
import os.path
import pathlib
import shutil
import sys
import threading
import time
import traceback
from astropy.io import fits
import numpy as np
import Pyro4
from warwick.observatory.common import daemons, log, TryLock
from warwick.observatory.common.helpers import pyro_client_matches
from warwick.observatory.camera.andor import Config, CommandStatus, CameraStatus, atcore

# Set automatically when generating RPM package
SOFTWARE_VERSION = "UNKNOWN"

def process_frames(process_queue, stop_signal, camera_id, filter_name, output_path,
                   log_name, pipeline_daemon_name, pipeline_handover_timeout):
    """
    Helper process to save frames to disk.
    This uses a process (rather than a thread) to avoid the GIL stalling frame acquisition
    """
    pipeline_daemon = getattr(daemons, pipeline_daemon_name)
    while True:
        frame = process_queue.get()
        header = [
            (None, None, None),
            ('COMMENT', ' ---                DATE/TIME                --- ', ''),
            ('DATE-OBS', frame['start_time'],
             '[UTC] date that exposure was triggered'),
            ('DATE-END', frame['end_time'],
             '[UTC] date that data was received by PC'),
            ('EXPTIME', round(frame['exposure'], 3), '[s] exposure time'),
            ('TIME-SRC', 'NTP', 'times are measured using NTP-synced PC clock'),
            (None, None, None),
            ('COMMENT', ' ---           CAMERA INFORMATION            --- ', ''),
            ('CAMSWVER', SOFTWARE_VERSION, 'camera server software version'),
            ('CAMID', camera_id, 'camera identifier'),
            ('CAMERA', frame['camera_desc'], 'camera model and serial number'),
            ('FILTER', filter_name, 'filter installed in instrument arm'),
            ('CCD-TEMP', round(frame['temperature'], 2),
             '[deg c] CCD temperature at end of exposure'),
            ('SET-TEMP', frame['target_temperature'], '[deg c] CCD temperature set point'),
            ('TEMP-LCK', frame['temperature_locked'],
             'CCD temperature is locked to set point'),
            ('CCD-XBIN', frame['bin_x'], '[px] x binning'),
            ('CCD-YBIN', frame['bin_y'], '[px] y binning'),
            ('CCD-WIND', '[{}:{},{}:{}]'.format(
                frame['win_x'], frame['win_x'] + frame['win_width'] - 1,
                frame['win_y'], frame['win_y'] + frame['win_height'] - 1),
             '[x1:x2,y1:y2] readout region (detector coords)'),
            ('SHUTTER', 'AUTO' if frame['shutter_enabled'] else 'CLOSED', 'shutter mode'),
            ('IMAG-RGN', '[{}:{},{}:{}]'.format(
                frame['image_x1'], frame['image_x2'],
                frame['image_y1'], frame['image_y2']),
             '[x1:x2,y1:y2] image region (image coords)'),
            ('EXPCNT', frame['exposure_count'], 'running exposure count since EXPCREF'),
            ('EXPCREF', frame['exposure_count_reference'], 'date the exposure counter was reset'),
        ]

        hdu = fits.PrimaryHDU(frame['data'])

        # Using Card and append() to force comment cards to be placed inline
        for h in header:
            hdu.header.append(fits.Card(h[0], h[1], h[2]), end=True)

        # Save errors shouldn't interfere with preview updates, so we use a separate try/catch
        try:
            filename = '{}-{:08d}.fits'.format(camera_id, frame['exposure_count'])
            path = os.path.join(output_path, filename)

            # Simulate an atomic write by writing to a temporary file then renaming
            hdu.writeto(path + '.tmp', overwrite=True)
            shutil.move(path + '.tmp', path)
            print('Saving temporary frame: ' + filename)

        except Exception as e:
            stop_signal.value = True
            log.error(log_name, 'Failed to save temporary frame (' + str(e) + ')')

        # Hand frame over to the pipeline
        # This may block if the pipeline is busy
        try:
            with pipeline_daemon.connect(pipeline_handover_timeout) as pipeline:
                pipeline.notify_frame(camera_id, filename)
        except Exception as e:
            stop_signal.value = True
            log.error(log_name, 'Failed to hand frame to pipeline (' + str(e) + ')')

class CameraDaemon:
    """Daemon interface for andor camera"""
    def __init__(self, config):
        self._config = config
        self._status = CameraStatus.Disabled

        self._sdk = atcore.ATCore()
        self._handle = None

        self._command_lock = threading.Lock()
        self._status_lock = threading.Lock()

        self._camera_model = 'unknown'

        self._temperature = 0

        self._temperature_status = None
        self._target_temperature = config.temperature_setpoint

        # CCD size: loaded during init
        self._ccd_width = 0
        self._ccd_height = 0

        self._exposure_time = 1
        self._exposure_delay = 0

        # Limit and number of frames acquired during the next sequence
        # Set to 0 to run continuously
        self._sequence_frame_limit = 0

        # Number of frames acquired this sequence
        self._sequence_frame_count = 0

        # If non-None, time that the last pre-exposure delay was started
        self._sequence_exposure_delay_start_time = None

        # Time that the latest frame in the exposure was started
        self._sequence_exposure_start_time = datetime.datetime.utcnow()

        # Information for building the output filename
        self._output_directory = pathlib.Path(config.output_path)
        self._output_frame_prefix = config.output_prefix

        # Persistent frame counters
        self._counter_filename = config.expcount_path
        try:
            with open(self._counter_filename, 'r') as infile:
                data = json.load(infile)
                self._exposure_count = data['exposure_count']
                self._exposure_count_reference = data['exposure_reference']
        except Exception:
            now = datetime.datetime.utcnow().strftime('%Y-%m-%d')
            self._exposure_count = 0
            self._exposure_count_reference = now

        # Thread that runs the exposure sequence
        # Initialized by start() method
        self._acquisition_thread = None

        # Signal that the exposure sequence should be terminated
        # at end of the current frame
        self._stop_acquisition = False

        # Condition to support cancellation of the pre-exposure delay
        self._exposure_delay_condition = threading.Condition()

        # Thread for polling camera status
        status_thread = threading.Thread(target=self.__poll_camera_status)
        status_thread.daemon = True
        status_thread.start()

        # Subprocess for processing acquired frames
        self._processing_queue = Queue(maxsize=1)
        self._processing_stop_signal = Value(c_bool, False)

        processing_process = Process(target=process_frames, args=(
            self._processing_queue, self._processing_stop_signal, config.camera_id, config.filter, config.output_path,
            config.log_name, config.pipeline_daemon_name, config.pipeline_handover_timeout))
        processing_process.daemon = True
        processing_process.start()

    def __poll_camera_status(self):
        """Background thread that polls the camera status"""
        while True:
            # Query temperature
            with self._status_lock:
                if self._handle is not None:
                    # Query temperature status
                    self._temperature = self._sdk.get_float(self._handle, "SensorTemperature")
                    self._temperature_status = self._sdk.get_enum_string(self._handle, "TemperatureStatus")
                else:
                    self._status = CameraStatus.Disabled

            time.sleep(self._config.temperature_query_delay)

    def __set_target_temperature_and_cooler(self, target_temperature, cooler_enabled):
        """Set the camera temperature and cooler configuration
           Returns bool indicating success
        """
        try:
            self._sdk.set_enum_string(self._handle, 'TemperatureControl', '{:.1f}'.format(target_temperature))
            self._sdk.set_bool(self._handle, 'SensorCooling', cooler_enabled)
            return True
        except:
            traceback.print_exc(file=sys.stdout)
        return False

    def __set_exposure_time(self, exposure_seconds):
        """Sets the given exposure time in seconds
           Returns bool indicating success
        """
        try:
            self._sdk.set_float(self._handle, "ExposureTime", exposure_seconds)
            self._exposure_time = exposure_seconds
            return True
        except Exception:
            traceback.print_exc(file=sys.stdout)
        return False

    def __run_exposure_sequence(self):
        """Worker thread that acquires frames and their times.
           Tagged frames are pushed to the acquisition queue
           for further processing on another thread"""
        try:
            self._processing_stop_signal.value = False
            while not self._stop_acquisition and not self._processing_stop_signal.value:
                # Delay before starting exposures
                if self._exposure_delay > 0:
                    self._sequence_exposure_delay_start_time = datetime.datetime.utcnow()
                    with self._exposure_delay_condition:
                        self._exposure_delay_condition.wait(self._exposure_delay)

                    self._sequence_exposure_delay_start_time = None
                    if self._stop_acquisition or self._processing_stop_signal.value:
                        break

                image_bytes = self._sdk.get_int(self._handle, "ImageSizeBytes")
                raw_buffer = np.empty((image_bytes,), dtype='B')

                print('image bytes', image_bytes)
                print('Exposure time', self._sdk.get_float(self._handle, 'ExposureTime'))
                print('FrameRate', self._sdk.get_float(self._handle, 'FrameRate'))
                print('TriggerMode', self._sdk.get_enum_string(self._handle, 'TriggerMode'))

                try:
                    self._sdk.queue_buffer(self._handle, raw_buffer.ctypes.data, image_bytes)

                    start_time = datetime.datetime.utcnow()
                    self._sdk.command(self._handle, "AcquisitionStart")
                except Exception:
                    traceback.print_exc(file=sys.stdout)
                    log.error(self._config.log_name, 'Failed to start exposure sequence')
                    break

                self._sequence_exposure_start_time = start_time

                try:
                    self._sdk.wait_buffer(self._handle)
                    end_time = datetime.datetime.utcnow()
                except Exception:
                    traceback.print_exc(file=sys.stdout)
                    log.error(self._config.log_name, 'Failed to wait for exposure to complete')
                    break

                config = {
                    'aoiheight': self._sdk.get_int(self._handle, "AOIHeight"),
                    'aoiwidth': self._sdk.get_int(self._handle, "AOIWidth"),
                    'aoistride': self._sdk.get_int(self._handle, "AOIStride"),
                    'pixelencoding': self._sdk.get_enum_string(self._handle, "PixelEncoding")
                }

                np_arr = raw_buffer[0:config['aoiheight'] * config['aoistride']]
                np_d = np_arr.view(dtype='H')
                np_d = np_d.reshape(config['aoiheight'], round(np_d.size / config['aoiheight']))
                data = np_d[0:config['aoiheight'], 0:config['aoiwidth']]

                self._exposure_count += 1

                # Save updated counts to disk
                with open(self._counter_filename, 'w') as outfile:
                    json.dump({
                        'exposure_count': self._exposure_count,
                        'exposure_reference': self._exposure_count_reference,
                    }, outfile)

                self._processing_queue.put({
                    'data': data,
                    'start_time': start_time.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3],
                    'end_time': end_time.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3],
                    'exposure': self._exposure_time,
                    'camera_desc': self._camera_model + ' ({})'.format(self._config.camera_serial),
                    'temperature': self._temperature,
                    'target_temperature': self._target_temperature,
                    'temperature_locked': self._temperature_status == 'Stabilised',
                    'shutter_enabled': True,
                    'exposure_count': self._exposure_count,
                    'exposure_count_reference': self._exposure_count_reference,
                    'win_x': 1,
                    'win_y': 1,
                    'win_width': self._ccd_width,
                    'win_height': self._ccd_height,
                    'bin_x': 1,
                    'bin_y': 1,
                    'image_x1': 1,
                    'image_x2': 1 + self._ccd_width,
                    'image_y1': 1,
                    'image_y2': 1 + self._ccd_height
                })

                # Continue exposure sequence?
                self._sequence_frame_count += 1
                if 0 < self._sequence_frame_limit <= self._sequence_frame_count:
                    self._stop_acquisition = True
        finally:
            log.info(self._config.log_name, 'Exposure sequence complete')
            self._status = CameraStatus.Idle

    @Pyro4.expose
    def set_target_temperature(self, temperature, quiet=False):
        """Set the camera temperature (if given a number) or warm up (if given None)"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if temperature is None:
                success = self.__set_target_temperature_and_cooler(self._target_temperature, False)
            else:
                if '{:.1f}'.format(temperature) not in ['-45.0', '-25.0', '15.0']:
                    return CommandStatus.TemperatureOutsideLimits

                success = self.__set_target_temperature_and_cooler(temperature, True)

            if not success:
                return CommandStatus.Failed

            if not quiet:
                if temperature is None:
                    log.info(self._config.log_name, 'Warming camera')
                else:
                    log.info(self._config.log_name, 'Target temperature set to ' + str(temperature))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def report_status(self):
        """Returns a dictionary containing the current camera state"""
        data = {'state': self._status}
        if self._status != CameraStatus.Disabled:

            # Estimate the current frame progress based on the time delta
            exposure_progress = 0
            delay_progress = 0
            if self._status == CameraStatus.Acquiring:
                if self._sequence_exposure_delay_start_time:
                    data['state'] = CameraStatus.Waiting
                    delta = datetime.datetime.utcnow() - self._sequence_exposure_delay_start_time
                    delay_progress = delta.total_seconds()
                else:
                    delta = datetime.datetime.utcnow() - self._sequence_exposure_start_time
                    exposure_progress = delta.total_seconds()
                    if exposure_progress > self._exposure_time:
                        data['state'] = CameraStatus.Reading
                        exposure_progress = 0

            data.update({
                'temperature': self._temperature,
                'temperature_locked': self._temperature_status == 'Stabilised',
                'temperature_status': self._temperature_status,
                'target_temperature': self._target_temperature,
                'shutter_enabled': True,
                'window': [
                    0, self._ccd_width,
                    0, self._ccd_height,
                ],
                'exposure_time': self._exposure_time,
                'exposure_progress': exposure_progress,
                'delay_time': self._sequence_exposure_delay_start_time,
                'delay_progress': delay_progress,
                'sequence_frame_limit': self._sequence_frame_limit,
                'sequence_frame_count': self._sequence_frame_count,
            })
        return data

    @Pyro4.expose
    def initialize(self):
        """Connects to the camera driver"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status != CameraStatus.Disabled:
                return CommandStatus.CameraNotUninitialized

            self._status = CameraStatus.Initializing
            try:
                num_cameras = self._sdk.get_int(self._sdk.AT_HNDL_SYSTEM, "DeviceCount")
                if num_cameras == 0:
                    return CommandStatus.CameraNotFound

                found = False

                print('{} cameras available'.format(num_cameras))
                for i in range(num_cameras):
                    handle = self._sdk.open(i)
                    model = self._sdk.get_string(handle, "CameraModel")
                    serial = self._sdk.get_string(handle, "SerialNumber")

                    print('camera {} is {} ({})'.format(i, model, serial))
                    if serial == self._config.camera_serial:
                        found = True
                        break
                    else:
                        self._sdk.close(handle)

                if not found:
                    print('camera with serial {} was not found'.format(self._config.camera_serial))
                    return CommandStatus.CameraNotFound

                # Query detector size
                width = self._sdk.get_int(handle, 'SensorWidth')
                height = self._sdk.get_int(handle, 'SensorHeight')

                # Configure standard 2D image readout
                print('TriggerMode', self._sdk.get_enum_string(handle, 'TriggerMode'))

                self._sdk.set_enum_string(handle, 'PixelEncoding', 'Mono16')
                self._sdk.set_enum_string(handle, 'AOIBinning', '1x1')
                self._sdk.set_enum_string(handle, 'TriggerMode', 'Internal')
                self._sdk.set_enum_string(handle, 'CycleMode', 'Fixed')
                self._sdk.set_int(handle, 'FrameCount', 1)
                self._sdk.set_float(handle, 'ExposureTime', self._exposure_time)
                self._sdk.set_enum_string(handle, 'GainMode', 'High dynamic range (16-bit)')
                self._sdk.set_enum_string(handle, 'TemperatureControl', '{:.1f}'.format(self._config.temperature_setpoint))
                self._sdk.set_bool(handle, 'SensorCooling', True)

                with self._status_lock:
                    self._handle = handle
                    self._camera_model = model
                    self._ccd_width = width
                    self._ccd_height = height

                    self._status = CameraStatus.Idle
                    print('camera {} ({}) initalized'.format(self._camera_model, self._config.camera_serial))

                return CommandStatus.Succeeded
            except Exception:
                traceback.print_exc(file=sys.stdout)
                return CommandStatus.Failed
            finally:
                # Clean up on failure
                if self._status != CameraStatus.Idle:
                    if handle:
                        self._sdk.close(handle)
                    self._status = CameraStatus.Disabled
                    log.error(self._config.log_name, 'Failed to initialize camera')
                else:
                    log.info(self._config.log_name, 'Initialized camera')

    @Pyro4.expose
    def configure(self, params, quiet=False):
        """Set camera configuration to the requested state
           params should be a dictionary with the following keys:
              temperature: Temperature set point
              cooler: Enable the cooler (True/False)
              shutter: Enable the shutter (True/False)
              gainindex: Gain index
              readoutindex: Readout index
              delay: Pre-exposure delay in seconds
              exposure: Exposure time in seconds
              window: Tuple of (binx, biny, x, y, width, height)
           Any properties not specified in params will be reset to its default

           The params dictionary should be validated using the
           schema returned by the configure_validation_schema helper

            Set quiet=True to disable log messages
        """
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            # Reset cooling
            temperature = params.get('temperature', self._config['temperature'])
            cooler = params.get('cooler', True)
            if not self.__set_target_temperature_and_cooler(temperature, cooler):
                return CommandStatus.Failed

            log.info(self._log_table, 'Target temperature set to ' + str(temperature))
            log.info(self._log_table, 'Cooler ' + ('enabled' if cooler else 'disabled'))

            # Reset shutter
            #shutter = params.get('shutter', False)
            #if self.__set_shutter(shutter) != AndorStatus.Success:
            #    return CommandStatus.Failed

            #log.info(self._log_table, 'Shutter set to ' + ('auto' if shutter else 'closed'))

            # Reset gain
            #gain_index = params.get('gainindex', self._config['gainindex'])
            #gain_status = self.__set_gain_index(gain_index)
            #if gain_status == AndorStatus.DrvP1Invalid:
            #    return CommandStatus.InvalidGainIndex
            #if gain_status != AndorStatus.Success:
            #    return CommandStatus.Failed

            #log.info(self._log_table, 'Gain index set to ' +  str(gain_index))

            # Reset readout speed
            #shift_speed_index = params.get('readoutindex', self._config['horizontalshiftindex'])
            #readout_status = self.__set_horizontal_shift_index(shift_speed_index)
            #if readout_status == AndorStatus.DrvP2Invalid:
            #    return CommandStatus.InvalidShiftSpeedIndex
            #if readout_status != AndorStatus.Success:
            #    return CommandStatus.Failed

            #log.info(self._log_table, 'Readout speed index set to ' +  str(shift_speed_index))

            # Reset exposure delay
            self._exposure_delay = params.get('delay', 0)

            if not quiet:
                log.info(self._config.log_name, 'Exposure delay set to {:.3f}s'.format(self._exposure_delay))

            # Reset exposure time
            exposure = params.get('exposure', 1)
            if not self.__set_exposure_time(exposure):
                return CommandStatus.Failed

            if not quiet:
                log.info(self._config.log_name, 'Exposure time set to {:.3f}s'.format(exposure))

            # Reset readout geometry
            #w = params.get('window', (1, 1, 1, 1, self._ccd_width, self._ccd_height))
            #if len(w) != 6:
            #    return CommandStatus.InvalidWindow

            #if not self.__set_ccd_geometry(w[0], w[1], w[2], w[3], w[4], w[5]):
            #    return CommandStatus.InvalidWindow

            #log.info(self._log_table, 'Binning set to {}x{}'.format(w[0], w[1]))
            #log.info(self._log_table, 'Window set to [{}:{},{}:{}]'.format(w[2], w[4], w[3], w[5]))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_exposure(self, seconds, quiet=False):
        """Set the exposure time in seconds"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            if not self.__set_exposure_time(seconds):
                return CommandStatus.Failed

            if not quiet:
                log.info(self._config.log_name, 'Exposure time set to {:.3f}s'.format(seconds))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_exposure_delay(self, seconds, quiet=False):
        """Set the pre-exposure delay in seconds"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            self._exposure_delay = seconds

            if not quiet:
                log.info(self._config.log_name, 'Exposure delay set to {:.3f}s'.format(seconds))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_binning(self, bin_x, bin_y, quiet=False):
        """Sets the CCD readout binning (both x and y)"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            return CommandStatus.Failed

    @Pyro4.expose
    def set_window(self, x, y, width, height, quiet=False):
        """Sets the CCD readout window in unbinned (hardware) pixels"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            if x < 1 or y < 1 or x + width - 1 > self._ccd_width or \
                    y + height - 1 > self._ccd_height:
                return CommandStatus.WindowOutsideCCD

            return CommandStatus.Failed

    @Pyro4.expose
    def shutdown(self):
        """Disconnects from the camera driver"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            # Complete the current exposure
            if self._acquisition_thread is not None:
                self._sdk.command(self._handle, "AcquisitionStop")

                print('shutdown: waiting for acquisition to complete')
                self._stop_acquisition = True
                self._acquisition_thread.join()

                print('shutdown: disconnecting camera')
                if self._handle:
                    self._sdk.close(self._handle)

            log.info(self._config.log_name, 'Shutdown camera')
            return CommandStatus.Succeeded

    @Pyro4.expose
    def start_sequence(self, count, quiet=False):
        """Starts an exposure sequence with a set number of frames, or 0 to run until stopped"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            print('starting exposure sequence')
            count_msg = 'until stopped'
            if count == 1:
                count_msg = '1 frame'
            elif count > 1:
                count_msg = str(count) + ' frames'

            if not quiet:
                log.info(self._config.log_name, 'Starting exposure sequence (' + count_msg + ')')

            self._sequence_frame_limit = count
            self._sequence_frame_count = 0
            self._stop_acquisition = False
            self._acquisition_thread = threading.Thread(target=self.__run_exposure_sequence)
            self._acquisition_thread.daemon = False
            self._acquisition_thread.start()
            self._status = CameraStatus.Acquiring

            return CommandStatus.Succeeded

    @Pyro4.expose
    def stop_sequence(self):
        """Stops any active exposure sequence"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        if self._status == CameraStatus.Disabled:
            return CommandStatus.CameraNotInitialized

        # Note that the Waiting and Reading statuses are artificial
        # self._status stays as CameraStatus.Acquiring during both of these
        if self._status != CameraStatus.Acquiring:
            return CommandStatus.CameraNotAcquiring

        self._status = CameraStatus.Aborting
        log.info(self._config.log_name, 'Aborting exposure sequence')
        self._sdk.command(self._handle, "AcquisitionStop")

        self._sequence_frame_count = 0
        self._stop_acquisition = True

        with self._exposure_delay_condition:
            self._exposure_delay_condition.notify_all()

        return CommandStatus.Succeeded

    @Pyro4.expose
    def set_shutter(self, enabled, quiet=False):
        """Enable or disable the shutter"""
        return CommandStatus.Succeeded

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Camera control daemon')
    parser.add_argument('config', help='Path to configuration json file')
    args = parser.parse_args()
    c = Config(args.config)
    c.daemon.launch(CameraDaemon(c))
