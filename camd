#!/usr/bin/env python3
#
# This file is part of camd.
#
# camd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# camd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with camd.  If not, see <http://www.gnu.org/licenses/>.

"""Daemon for controlling the Warwick one-metre telescope cameras via Pyro"""

# pylint: disable=invalid-name
# pylint: disable=too-many-return-statements
# pylint: disable=too-few-public-methods
# pylint: disable=too-many-instance-attributes
# pylint: disable=no-self-use

from ctypes import c_float, c_int32, c_int, byref, CDLL
import threading
import time
import Pyro4

PYRO_COMM_TIMEOUT = 5

CAMD_HOST = '192.168.0.101'
CAMD_PORT = 9010
CAMD_NAME = 'cam_daemon'

# Delay between camera state queries (in seconds)
STATUS_QUERY_DELAY = 1

# This should be kept in sync with the dictionary in cam
class CommandStatus:
    """Numeric return codes"""
    # General error codes
    Succeeded = 0
    Failed = 1
    Blocked = 2

    CameraNotFound = 5

    # Command-specific codes
    CameraNotInitialized = 10
    CameraNotUninitialized = 14

class CameraStatus:
    """Status of the camera hardware"""
    Disabled, Idle, Exposing, Reading = range(4)

class AndorStatus:
    """Status codes returned by libandor"""
    Success = 20002

    # Temperature status
    TemperatureStabilized = 20036
    TemperatureOff = 20034

class TryLock(object):
    """Helper object for use with `with` statements"""
    def __init__(self, lock):
        self._lock = lock
        self._locked = False

    def __enter__(self):
        self._locked = self._lock.acquire(False)
        return self._locked

    def __exit__(self, *args):
        if self._locked:
            self._lock.release()
            self._locked = False

class CameraDaemon:
    """Daemon interface for talon subystems"""
    def __init__(self):
        self._status = CameraStatus.Disabled

        self._driver = None
        self._driver_lock = threading.Lock()

        self._status_condition = threading.Condition()
        self._command_lock = threading.Lock()

        self._temperature = 0
        self._temperature_locked = False
        self._cooler_enabled = False

        status_thread = threading.Thread(target=self.__poll_camera_status)
        status_thread.daemon = True
        status_thread.start()

    def __poll_camera_status(self):
        """Background thread that polls the camera status"""
        while True:
            with self._driver_lock:
                if self._driver is not None:
                    # TODO: set this properly
                    self._status = CameraStatus.Idle

                    # Query temperature status
                    temp = c_float()
                    status = self._driver.GetTemperatureF(byref(temp))
                    self._temperature = temp.value
                    self._temperature_locked = status == AndorStatus.TemperatureStabilized
                    self._cooler_enabled = status != AndorStatus.TemperatureOff
                    print(self._temperature, self._temperature_locked, self._cooler_enabled)
                else:
                    self._status = CameraStatus.Disabled
            time.sleep(STATUS_QUERY_DELAY)

    @Pyro4.expose
    def set_temperature(self, temperature, enable_cooling):
        """Set the target camera temperature and cooling status"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            with self._driver_lock:
                if self._driver is None:
                    return CommandStatus.Failed

                # TODO: Check limits and return specific error code if invalid
                temp = c_int(temperature)
                print('setting temp to {}'.format(temp))
                status = self._driver.SetTemperature(temp)
                if status != AndorStatus.Success:
                    return CommandStatus.Failed

                if enable_cooling:
                    status = self._driver.CoolerON()
                else:
                    status = self._driver.CoolerOFF()

                if status != AndorStatus.Success:
                    return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def report_status(self):
        """Returns a dictionary containing the current camera state"""
        data = {'state': self._status}
        if self._status != CameraStatus.Disabled:
            data.update({
                'temperature': self._temperature,
                'temperature_locked': self._temperature_locked,
                'cooler_enabled': self._cooler_enabled
            })
        return data

    @Pyro4.expose
    def initialize(self):
        """Connects to the camera driver"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status != CameraStatus.Disabled:
                return CommandStatus.CameraNotUninitialized

            print('initializing driver')
            driver = CDLL('libandor.so')
            num_cameras = c_int32()
            status = driver.GetAvailableCameras(byref(num_cameras))
            if status != AndorStatus.Success or num_cameras.value == 0:
                return CommandStatus.CameraNotFound

            print('{} cameras available'.format(num_cameras.value))
            print('using first camera')

            handle = c_int32()
            status = driver.GetCameraHandle(c_int32(0), byref(handle))
            if status != AndorStatus.Success:
                print('failed to query camera handle with status {}'.format(status))
                return CommandStatus.Failed

            status = driver.SetCurrentCamera(handle)
            if status != AndorStatus.Success:
                print('failed to set current camera with status {}'.format(status))
                return CommandStatus.Failed

            status = driver.Initialize('/usr/local/etc/andor'.encode('ascii'))
            if status != AndorStatus.Success:
                print('failed to initialize camera with status {}'.format(status))
                return CommandStatus.Failed

            with self._driver_lock:
                self._driver = driver

            return CommandStatus.Succeeded

    @Pyro4.expose
    def shutdown(self):
        """Disconnects from the camera driver"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            with self._driver_lock:
                print('killing driver')
                self._driver.ShutDown()
                self._driver = None

            return CommandStatus.Succeeded

    @Pyro4.expose
    def stop(self):
        """Stops any active exposure sequence"""
        if self._status == CameraStatus.Disabled:
            return CommandStatus.CameraNotInitialized

        return CommandStatus.Succeeded

def spawn_daemon():
    """Spawns the daemon and registers it with Pyro"""
    Pyro4.config.COMMTIMEOUT = PYRO_COMM_TIMEOUT
    Pyro4.config.REQUIRE_EXPOSE = True

    pyro = Pyro4.Daemon(host=CAMD_HOST, port=CAMD_PORT)
    camera = CameraDaemon()
    uri = pyro.register(camera, objectId=CAMD_NAME)

    print('Starting camera daemon with Pyro ID:', uri)
    pyro.requestLoop()
    print('Stopping camera daemon with Pyro ID:', uri)

if __name__ == '__main__':
    spawn_daemon()
