#!/usr/bin/env python3
#
# This file is part of the Robotic Observatory Control Kit (rockit)
#
# rockit is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# rockit is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with rockit.  If not, see <http://www.gnu.org/licenses/>.

"""Daemon for controlling the Warwick one-metre telescope cameras via Pyro"""

# pylint: disable=too-many-return-statements
# pylint: disable=too-many-branches
# pylint: disable=too-many-statements
# pylint: disable=too-many-lines
# pylint: disable=too-many-instance-attributes

import argparse
from ctypes import c_bool, c_float, c_int32, c_int, c_uint16, c_long, byref, create_string_buffer, CDLL
import datetime
import json
from multiprocessing import Process, Queue, Value
import os.path
import pathlib
import shutil
import threading
import time
from astropy.io import fits
import numpy
import Pyro4
from rockit.common import daemons, log, TryLock
from rockit.common.helpers import pyro_client_matches
from rockit.camera.andor2 import Config, CommandStatus, CameraStatus


class AndorStatus:
    """Status codes returned by libandor"""
    Success = 20002

    # Temperature status
    TemperatureStabilized = 20036
    TemperatureOff = 20034

    # Setting readout geometry
    DrvP1Invalid = 20066
    DrvP2Invalid = 20067
    DrvP3Invalid = 20068
    DrvP4Invalid = 20069
    DrvP5Invalid = 20076
    DrvP6Invalid = 20077


def process_frames(process_queue, stop_signal, camera_id, filter_name, output_path,
                   header_card_capacity, log_name,
                   pipeline_daemon_name, pipeline_handover_timeout):
    """
    Helper process to save frames to disk.
    This uses a process (rather than a thread) to avoid the GIL stalling frame acquisition
    """
    pipeline_daemon = getattr(daemons, pipeline_daemon_name)
    while True:
        frame = process_queue.get()

        if frame['image_region'] is not None:
            i = frame['image_region']
            image_region_header = ('IMAG-RGN', f'[{i[0]}:{i[1]},{i[2]}:{i[3]}]',
                                   '[x1:x2,y1:y2] image region (image coords)')
        else:
            image_region_header = ('COMMENT', ' IMAG-RGN not available', '')

        w = frame['window_region']
        header = [
            (None, None, None),
            ('COMMENT', ' ---                DATE/TIME                --- ', ''),
            ('DATE-OBS', frame['start_time'],
             '[UTC] date that exposure was triggered'),
            ('DATE-END', frame['end_time'],
             '[UTC] date that data was received by PC'),
            ('EXPTIME', round(frame['exposure'], 3), '[s] exposure time'),
            ('TIME-SRC', 'NTP', 'times are measured using NTP-synced PC clock'),
            (None, None, None),
            ('COMMENT', ' ---           CAMERA INFORMATION            --- ', ''),
            ('CAMID', camera_id, 'camera identifier'),
            ('CAMERA', frame['camera_desc'], 'camera model and serial number'),
            ('FILTER', filter_name, 'filter installed in instrument arm'),
            ('CCD-TEMP', round(frame['temperature'], 2), '[deg c] CCD temperature at end of exposure'),
            ('SET-TEMP', frame['target_temperature'], '[deg c] CCD temperature set point'),
            ('TEMP-LCK', frame['temperature_locked'], 'CCD temperature is locked to set point'),
            ('CAM-XBIN', frame['window_bin'][0], '[px] x binning'),
            ('CAM-YBIN', frame['window_bin'][1], '[px] y binning'),
            ('CAM-WIND', f'[{w[0]}:{w[1]},{w[2]}:{w[3]}]', '[x1:x2,y1:y2] readout region (detector coords)'),
            ('CAM-GAIN', frame['gain'], '[e-/DN] nominal readout gain'),
            ('CAM-RSPD', frame['horizontal_shift_speed'], '[MHz] CCD readout speed'),
            ('SHUTTER', 'AUTO' if frame['shutter_enabled'] else 'CLOSED', 'shutter mode'),
            image_region_header,
            ('EXPCNT', frame['exposure_count'], 'running exposure count since EXPCREF'),
            ('EXPCREF', frame['exposure_count_reference'], 'date the exposure counter was reset'),
            ('SHTRCNT', frame['shutter_count'], 'running shutter count since SHTRCREF'),
            ('SHTRCREF', frame['shutter_count_reference'], 'date the shutter counter was reset'),
        ]

        hdu = fits.PrimaryHDU(frame['data'])

        # Using Card and append() to force comment cards to be placed inline
        for h in header:
            hdu.header.append(fits.Card(h[0], h[1], h[2]), end=True)

        # Pad with sufficient blank cards that pipelined won't need to allocate extra header blocks
        padding = max(0, header_card_capacity - len(hdu.header) - 1)
        for _ in range(padding):
            hdu.header.append(fits.Card(None, None, None), end=True)

        # Save errors shouldn't interfere with preview updates, so we use a separate try/catch
        filename = f'{camera_id}-{frame["exposure_count"]:08d}.fits'
        try:
            path = os.path.join(output_path, filename)

            # Simulate an atomic write by writing to a temporary file then renaming
            hdu.writeto(path + '.tmp', overwrite=True)
            shutil.move(path + '.tmp', path)
            print('Saving temporary frame: ' + filename)

        except Exception as e:
            stop_signal.value = True
            log.error(log_name, f'Failed to save temporary frame ({e})')

        # Hand frame over to the pipeline
        # This may block if the pipeline is busy
        try:
            with pipeline_daemon.connect(pipeline_handover_timeout) as pipeline:
                pipeline.notify_frame(camera_id, filename)
        except Exception as e:
            stop_signal.value = True
            log.error(log_name, f'Failed to hand frame to pipeline ({e})')


class CameraDaemon:
    """Daemon interface for andor camera"""
    def __init__(self, config):
        self._config = config
        self._status = CameraStatus.Disabled

        self._driver = None
        self._driver_lock = threading.Lock()

        self._status_condition = threading.Condition()
        self._command_lock = threading.Lock()

        self._camera_model = 'unknown'

        self._temperature = 0
        self._temperature_locked = False
        self._cooler_enabled = False
        self._target_temperature = config.temperature_setpoint

        # Temperature limits: loaded during init
        self._min_temperature = 0
        self._max_temperature = 0

        # CCD size: loaded during init
        self._ccd_width = 0
        self._ccd_height = 0

        # Readout geometry: defaults loaded during init
        self._window_region = [0, 0, 0, 0]
        self._window_bin = [1, 1]

        # Image geometry: masking away the overscan on the red camera
        self._image_region = [0, 0, 0, 0]

        # Shutter enabled (opens during exposures), or remains closed
        self._shutter_enabled = False

        # Gain index. For blue camera: 0 = 1x, 1 = 2x, 2 = 4x
        self._gains = []
        self._gain_index = config.gain_index
        self._exposure_time = 1
        self._exposure_delay = 0

        # Horizontal shift speeds in MHz: loaded during init
        self._horizontal_shift_speeds = []
        self._horizontal_shift_speed_index = config.horizontal_shift_index

        # Limit and number of frames acquired during the next sequence
        # Set to 0 to run continuously
        self._sequence_frame_limit = 0

        # Number of frames acquired this sequence
        self._sequence_frame_count = 0

        # If non-None, time that the last pre-exposure delay was started
        self._sequence_exposure_delay_start_time = None

        # Time that the latest frame in the exposure was started
        self._sequence_exposure_start_time = datetime.datetime.utcnow()

        # Information for building the output filename
        self._output_directory = pathlib.Path(config.output_path)
        self._output_frame_prefix = config.output_prefix

        # Persistent frame counters
        self._counter_filename = config.expcount_path
        try:
            with open(self._counter_filename, 'r', encoding='utf-8') as infile:
                data = json.load(infile)
                self._exposure_count = data['exposure_count']
                self._exposure_count_reference = data['exposure_reference']
                self._shutter_count = data['shutter_count']
                self._shutter_count_reference = data['shutter_reference']
        except Exception:
            now = datetime.datetime.utcnow().strftime('%Y-%m-%d')
            self._exposure_count = 0
            self._exposure_count_reference = now
            self._shutter_count = 0
            self._shutter_count_reference = now

        # Thread that runs the exposure sequence
        # Initialized by start() method
        self._acquisition_thread = None

        # Signal that the exposure sequence should be terminated
        # at end of the current frame
        self._stop_acquisition = False

        # Condition to support cancellation of the pre-exposure delay
        self._exposure_delay_condition = threading.Condition()

        # Thread for polling camera status
        threading.Thread(target=self.__poll_camera_status, daemon=True).start()

        # Subprocess for processing acquired frames
        self._processing_queue = Queue(maxsize=1)
        self._processing_stop_signal = Value(c_bool, False)

        Process(target=process_frames, daemon=True, args=(
            self._processing_queue, self._processing_stop_signal, config.camera_id, config.filter, config.output_path,
            config.header_card_capacity, config.log_name,
            config.pipeline_daemon_name, config.pipeline_handover_timeout)
        ).start()

    def __poll_camera_status(self):
        """Background thread that polls the camera status"""
        while True:
            # Query temperature
            with self._driver_lock:
                if self._driver is not None:
                    # Query temperature status
                    temp = c_float()
                    status = self._driver.GetTemperatureF(byref(temp))
                    self._temperature = temp.value
                    self._temperature_locked = status == AndorStatus.TemperatureStabilized
                    self._cooler_enabled = status != AndorStatus.TemperatureOff
                else:
                    self._status = CameraStatus.Disabled

            time.sleep(self._config.temperature_query_delay)

    def __set_target_temperature_and_cooler(self, target_temperature, cooler_enabled):
        """Set the camera temperature and cooler configuration
           Returns an AndorStatus return code
        """

        with self._driver_lock:
            if self._driver is None:
                return False

            status = self._driver.SetTemperature(c_int(target_temperature))
            if status != AndorStatus.Success:
                print(f'failed to set temperature to {target_temperature} with status {status}')
                return status

            self._target_temperature = target_temperature
            if cooler_enabled:
                status = self._driver.CoolerON()
            else:
                status = self._driver.CoolerOFF()

            return status

    def __set_shutter(self, enabled):
        """Set the shutter to open automatically or stay closed
           Returns an AndorStatus return code
        """
        with self._driver_lock:
            value = c_int(0 if enabled else 2)
            status = self._driver.SetShutter(c_int(1), value, c_int(50), c_int(50))
            if status == AndorStatus.Success:
                self._shutter_enabled = enabled
            else:
                mode = 'auto' if enabled else 'closed'
                print(f'failed to set shutter {mode} with status {status}')
            return status

    def __set_gain_index(self, gain_index):
        """Sets the gain to the requested index
           Returns an AndorStatus return code
        """
        with self._driver_lock:
            status = self._driver.SetPreAmpGain(c_int(gain_index))
            if status == AndorStatus.Success:
                self._gain_index = gain_index
            else:
                print(f'failed to set gain {gain_index} with status {status}')
        return status

    def __set_horizontal_shift_index(self, shift_speed_index):
        """Sets the horizontal shift speed to the requested index
           Returns an AndorStatus return code
        """
        with self._driver_lock:
            status = self._driver.SetHSSpeed(c_int(0), c_int(shift_speed_index))
            if status == AndorStatus.Success:
                self._horizontal_shift_speed_index = shift_speed_index
            else:
                print(f'failed to set horizontal shift {shift_speed_index} with status {status}')
        return status

    def __set_exposure_time(self, exposure_seconds):
        """Sets the given exposure time in seconds
           Returns an AndorStatus return code
        """
        with self._driver_lock:
            status = self._driver.SetExposureTime(c_float(exposure_seconds))
            if status == AndorStatus.Success:
                self._exposure_time = exposure_seconds
            else:
                print(f'failed to set exposure ({exposure_seconds}s) with status {status}')
        return status

    def __run_exposure_sequence(self):
        """Worker thread that acquires frames and their times.
           Tagged frames are pushed to the acquisition queue
           for further processing on another thread"""
        try:
            self._processing_stop_signal.value = False
            readout_width = (self._window_region[1] - self._window_region[0] + 1) // self._window_bin[0]
            readout_height = (self._window_region[3] - self._window_region[2] + 1) // self._window_bin[1]
            pixel_count = readout_width * readout_height
            while not self._stop_acquisition and not self._processing_stop_signal.value:
                framedata = bytearray(pixel_count * 2)

                # Delay before starting exposures
                if self._exposure_delay > 0:
                    self._sequence_exposure_delay_start_time = datetime.datetime.utcnow()
                    with self._exposure_delay_condition:
                        self._exposure_delay_condition.wait(self._exposure_delay)

                    self._sequence_exposure_delay_start_time = None
                    if self._stop_acquisition or self._processing_stop_signal.value:
                        break

                with self._driver_lock:
                    start_time = datetime.datetime.utcnow()
                    status = self._driver.StartAcquisition()
                    if status != AndorStatus.Success:
                        log.error(self._config.log_name, f'Failed to start exposure sequence ({status})')
                        break

                self._sequence_exposure_start_time = start_time

                # TODO: thread safety: do we need the driver lock?
                status = self._driver.WaitForAcquisition()
                if status != AndorStatus.Success:
                    log.error(self._config.log_name, f'Failed to wait for acquisition ({status})')
                    break

                end_time = datetime.datetime.utcnow()
                cdata = (c_uint16 * pixel_count).from_buffer(framedata)
                status = self._driver.GetAcquiredData16(byref(cdata), c_long(pixel_count))
                if status != AndorStatus.Success:
                    if not self._stop_acquisition:
                        log.error(self._config.log_name, f'Failed to query frame data ({status})')
                    break

                self._exposure_count += 1
                if self._shutter_enabled:
                    self._shutter_count += 1

                # pylint: disable=no-member
                data = numpy.frombuffer(framedata, dtype=numpy.uint16).reshape((readout_height, readout_width))
                # pylint: enable=no-member

                self._processing_queue.put({
                    'data': data,
                    'start_time': start_time.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3],
                    'end_time': end_time.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3],
                    'exposure': self._exposure_time,
                    'camera_desc': f'{self._camera_model} ({self._config.camera_serial})',
                    'temperature': self._temperature,
                    'target_temperature': self._target_temperature,
                    'temperature_locked': self._temperature_locked,
                    'horizontal_shift_speed': self._horizontal_shift_speeds[self._horizontal_shift_speed_index],
                    'gain': self._gains[self._gain_index],
                    'shutter_enabled': self._shutter_enabled,
                    'exposure_count': self._exposure_count,
                    'exposure_count_reference': self._exposure_count_reference,
                    'shutter_count': self._shutter_count,
                    'shutter_count_reference': self._shutter_count_reference,
                    'window_bin': self._window_bin,
                    'window_region': self._window_region,
                    'image_region': self._image_region
                })

                # Continue exposure sequence?
                self._sequence_frame_count += 1
                if 0 < self._sequence_frame_limit <= self._sequence_frame_count:
                    self._stop_acquisition = True
        finally:
            # Save updated counts to disk
            with open(self._counter_filename, 'w', encoding='utf-8') as outfile:
                json.dump({
                    'exposure_count': self._exposure_count,
                    'exposure_reference': self._exposure_count_reference,
                    'shutter_count': self._shutter_count,
                    'shutter_reference': self._shutter_count_reference
                }, outfile)

            log.info(self._config.log_name, 'Exposure sequence complete')
            self._status = CameraStatus.Idle

    @Pyro4.expose
    def set_target_temperature(self, temperature, quiet=False):
        """Set the camera temperature (if given a number) or warm up (if given None)"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if temperature is None:
                status = self.__set_target_temperature_and_cooler(self._target_temperature, False)
            else:
                if temperature < self._min_temperature or temperature > self._max_temperature:
                    return CommandStatus.TemperatureOutsideLimits

                status = self.__set_target_temperature_and_cooler(temperature, True)

            if status != AndorStatus.Success:
                return CommandStatus.Failed

            if not quiet:
                if temperature is None:
                    log.info(self._config.log_name, 'Warming camera')
                else:
                    log.info(self._config.log_name, f'Target temperature set to {temperature}')
            return CommandStatus.Succeeded

    @Pyro4.expose
    def report_status(self):
        """Returns a dictionary containing the current camera state"""
        data = {'state': self._status}
        if self._status != CameraStatus.Disabled:
            shift_mhz = self._horizontal_shift_speeds[self._horizontal_shift_speed_index]
            gain_factor = self._gains[self._gain_index]

            # Estimate the current frame progress based on the time delta
            exposure_progress = 0
            delay_progress = 0
            if self._status == CameraStatus.Acquiring:
                if self._sequence_exposure_delay_start_time:
                    data['state'] = CameraStatus.Waiting
                    delta = datetime.datetime.utcnow() - self._sequence_exposure_delay_start_time
                    delay_progress = delta.total_seconds()
                else:
                    delta = datetime.datetime.utcnow() - self._sequence_exposure_start_time
                    exposure_progress = delta.total_seconds()
                    if exposure_progress > self._exposure_time:
                        data['state'] = CameraStatus.Reading
                        exposure_progress = 0

            data.update({
                'temperature': self._temperature,
                'temperature_locked': self._temperature_locked,
                'target_temperature': self._target_temperature,
                'cooler_enabled': self._cooler_enabled,
                'shutter_enabled': self._shutter_enabled,
                'exposure_time': self._exposure_time,
                'exposure_progress': exposure_progress,
                'delay_progress': delay_progress,
                'delay_total': self._exposure_delay,
                'gain_index': self._gain_index,
                'gain_factor': gain_factor,
                'horizontal_shift_speed_index': self._horizontal_shift_speed_index,
                'horizontal_shift_speed_mhz': shift_mhz,
                'window_bin': self._window_bin,
                'window_region': self._window_region,
                'sequence_frame_limit': self._sequence_frame_limit,
                'sequence_frame_count': self._sequence_frame_count,
            })
        return data

    @Pyro4.expose
    def initialize(self):
        """Connects to the camera driver"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status != CameraStatus.Disabled:
                return CommandStatus.CameraNotUninitialized

            self._status = CameraStatus.Initializing
            print('initializing driver')
            driver = CDLL('libandor.so')
            try:
                num_cameras = c_int32()
                status = driver.GetAvailableCameras(byref(num_cameras))
                if status != AndorStatus.Success or num_cameras.value == 0:
                    return CommandStatus.CameraNotFound

                # Enumerate cameras to find target
                handle = c_int32()
                model = create_string_buffer(4096)
                serial = c_int()
                found = False
                print(f'{num_cameras.value} cameras available')
                for i in range(num_cameras.value):
                    status = driver.GetCameraHandle(c_int32(i), byref(handle))
                    if status != AndorStatus.Success:
                        print(f'failed to query handle for camera {i}: status {status}')
                        continue

                    status = driver.SetCurrentCamera(handle)
                    if status != AndorStatus.Success:
                        print(f'failed to select camera {i}: status {status}')
                        continue

                    status = driver.Initialize('/usr/local/etc/andor'.encode('ascii'))
                    if status != AndorStatus.Success:
                        print(f'failed to initialize camera {i}: status {status}')
                        continue

                    status = driver.GetHeadModel(model)
                    if status != AndorStatus.Success:
                        print(f'failed to query camera {i} model: status {status}')
                        driver.ShutDown()
                        continue

                    status = driver.GetCameraSerialNumber(byref(serial))
                    if status != AndorStatus.Success:
                        print(f'failed to query camera {i} serial: status {status}')
                        driver.ShutDown()
                        continue

                    print(f'camera {i} is {model.value.decode("ascii")} ({serial.value})')

                    if serial.value == self._config.camera_serial:
                        found = True
                        break

                    driver.ShutDown()

                if not found:
                    driver = None
                    print(f'camera with serial {self._config.camera_serial} was not found')
                    return CommandStatus.CameraNotFound

                # Query cooler temperature limits
                min_temp = c_int(self._min_temperature)
                max_temp = c_int(self._max_temperature)
                status = driver.GetTemperatureRange(byref(min_temp), byref(max_temp))
                if status != AndorStatus.Success:
                    print(f'failed to query camera temperature limits with status {status}')
                    return CommandStatus.Failed

                # Query detector size
                width = c_int(self._ccd_width)
                height = c_int(self._ccd_height)
                status = driver.GetDetector(byref(width), byref(height))
                if status != AndorStatus.Success:
                    print(f'failed to query detector size with status {status}')
                    return CommandStatus.Failed

                # Set default shutter
                shutter = c_int(0 if self._shutter_enabled else 2)
                status = driver.SetShutter(c_int(1), shutter, c_int(50), c_int(50))
                if status != AndorStatus.Success:
                    print(f'failed to set shutter closed with status {status}')
                    return CommandStatus.Failed

                # Configure standard 2D image readout
                status = driver.SetReadMode(c_int(4))
                if status != AndorStatus.Success:
                    print(f'failed to set image readout mode with status {status}')
                    return CommandStatus.Failed

                # Camera does not support hardware timing, so we are forced to do individual
                # exposures via software
                status = driver.SetAcquisitionMode(c_int(1))
                if status != AndorStatus.Success:
                    print(f'failed to set acquisition mode with status {status}')
                    return CommandStatus.Failed

                # Set default exposure time
                status = driver.SetExposureTime(c_float(self._exposure_time))
                if status != AndorStatus.Success:
                    print(f'failed to set default exposure time with status {status}')
                    return CommandStatus.Failed

                # Query gains
                gain_count = c_int(0)
                status = driver.GetNumberPreAmpGains(byref(gain_count))
                if status != AndorStatus.Success:
                    print(f'failed to query gain count with status {status}')
                    return CommandStatus.Failed

                gains = []
                gain = c_float(0)
                for i in range(gain_count.value):
                    status = driver.GetPreAmpGain(c_int(i), byref(gain))
                    if status != AndorStatus.Success:
                        print(f'failed to query gain for index {i} with status {status}')
                        return CommandStatus.Failed
                    gains.append(gain.value)

                # Set default gain index
                status = driver.SetPreAmpGain(c_int(self._gain_index))
                if status != AndorStatus.Success:
                    print(f'failed to set default gain index with status {status}')
                    return CommandStatus.Failed

                # Query horizontal shift speeds
                # Assumes that there is only one readout channel, and no electron multiplication
                shift_count = c_int(0)
                status = driver.GetNumberHSSpeeds(c_int(0), c_int(0), byref(shift_count))
                if status != AndorStatus.Success:
                    print(f'failed to query horizontal shift speed count with status {status}')
                    return CommandStatus.Failed

                speeds = []
                speed = c_float(0)
                for i in range(shift_count.value):
                    status = driver.GetHSSpeed(c_int(0), c_int(0), c_int(i), byref(speed))
                    if status != AndorStatus.Success:
                        print(f'failed to query horizontal shift speed for index {i} with status {status}')
                        return CommandStatus.Failed
                    speeds.append(speed.value)

                # Set default horizontal shift index
                status = driver.SetHSSpeed(c_int(0), c_int(self._horizontal_shift_speed_index))
                if status != AndorStatus.Success:
                    print(f'failed to set default horizontal shift speed index with status {status}')
                    return CommandStatus.Failed

                # Set default readout geometry
                status = driver.SetImage(c_int(1), c_int(1),
                                         c_int(1), c_int(width.value),
                                         c_int(1), c_int(height.value))
                if status != AndorStatus.Success:
                    print(f'failed to set default readout geometry with status {status}')
                    return CommandStatus.Failed

                # Set default temperature
                status = driver.SetTemperature(c_int(self._target_temperature))
                if status != AndorStatus.Success:
                    print(f'failed to set default target temperature with status {status}')
                    return CommandStatus.Failed

                status = driver.CoolerON()
                if status != AndorStatus.Success:
                    print(f'failed to enable cooling with status {status}')
                    return CommandStatus.Failed

                with self._driver_lock:
                    self._driver = driver
                    self._camera_model = model.value.decode('ascii')
                    self._min_temperature = min_temp.value
                    self._max_temperature = max_temp.value
                    self._ccd_width = width.value
                    self._ccd_height = height.value
                    self._window_bin = [1, 1]
                    self._window_region = [1, self._ccd_width, 1, self._ccd_height]
                    self._image_region = [
                        self._config.overscan[0] + 1,
                        self._ccd_width - self._config.overscan[1],
                        1,
                        self._ccd_height
                    ]

                    self._gains = gains
                    self._horizontal_shift_speeds = speeds
                    self._status = CameraStatus.Idle
                    print(f'camera {self._camera_model} ({self._config.camera_serial}) initialized')

                return CommandStatus.Succeeded
            finally:
                # Clean up on failure
                if self._status != CameraStatus.Idle:
                    if driver is not None:
                        driver.ShutDown()
                    self._status = CameraStatus.Disabled
                    log.error(self._config.log_name, 'Failed to initialize camera')
                else:
                    log.info(self._config.log_name, 'Initialized camera')

    @Pyro4.expose
    def configure(self, params, quiet=False):
        """Set camera configuration to the requested state
           params should be a dictionary with the following keys:
              temperature: Temperature set point
              cooler: Enable the cooler (True/False)
              shutter: Enable the shutter (True/False)
              gainindex: Gain index
              readoutindex: Readout index
              delay: Pre-exposure delay in seconds
              exposure: Exposure time in seconds
              bin: Tuple of (bin-x, bin-y)
              window: Tuple of 1-indexed (x1, x2, y1, y2)
           Any properties not specified in params will be reset to its default

           The params dictionary should be validated using the
           schema returned by the configure_validation_schema helper

            Set quiet=True to disable log messages
        """
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            # Reset cooling
            temperature = params.get('temperature', self._config.temperature_setpoint)
            cooler = params.get('cooler', True)
            if self.__set_target_temperature_and_cooler(temperature, cooler) != AndorStatus.Success:
                return CommandStatus.Failed

            if not quiet:
                log.info(self._config.log_name, f'Target temperature set to {temperature}')
                log.info(self._config.log_name, 'Cooler ' + ('enabled' if cooler else 'disabled'))

            # Reset shutter
            shutter = params.get('shutter', False)
            if self.__set_shutter(shutter) != AndorStatus.Success:
                return CommandStatus.Failed

            if not quiet:
                log.info(self._config.log_name, 'Shutter set to ' + ('auto' if shutter else 'closed'))

            # Reset gain
            gain_index = params.get('gainindex', self._config.gain_index)
            gain_status = self.__set_gain_index(gain_index)
            if gain_status == AndorStatus.DrvP1Invalid:
                return CommandStatus.InvalidGainIndex
            if gain_status != AndorStatus.Success:
                return CommandStatus.Failed

            if not quiet:
                log.info(self._config.log_name, f'Gain index set to {gain_index}')

            # Reset readout speed
            shift_speed_index = params.get('readoutindex', self._config.horizontal_shift_index)
            readout_status = self.__set_horizontal_shift_index(shift_speed_index)
            if readout_status == AndorStatus.DrvP2Invalid:
                return CommandStatus.InvalidShiftSpeedIndex
            if readout_status != AndorStatus.Success:
                return CommandStatus.Failed

            if not quiet:
                log.info(self._config.log_name, f'Readout speed index set to {shift_speed_index}')

            # Reset exposure delay
            self._exposure_delay = params.get('delay', 0)

            if not quiet:
                log.info(self._config.log_name, f'Exposure delay set to {self._exposure_delay:.3f}s')

            # Reset exposure time
            exposure = params.get('exposure', 1)
            if self.__set_exposure_time(exposure) != AndorStatus.Success:
                return CommandStatus.Failed

            if not quiet:
                log.info(self._config.log_name, f'Exposure time set to {exposure:.3f}s')

            # Reset window and binning
            window = params.get('window', (1, self._ccd_width, 1, self._ccd_height))
            binning = params.get('bin', (1, 1))
            if len(window) != 4 or len(binning) != 2:
                return CommandStatus.InvalidWindow

            if not self.__set_readout_window(window, binning):
                return CommandStatus.InvalidWindow

            if not quiet:
                region = f'[{window[0]}:{window[1]},{window[2]}:{window[3]}]'
                log.info(self._config.log_name, f'Window set to {region}')
                log.info(self._config.log_name, f'Binning set to {binning[0]}x{binning[1]}')

            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_shutter(self, enabled, quiet=False):
        """Enable or disable the shutter"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            if self.__set_shutter(enabled) != AndorStatus.Success:
                return CommandStatus.Failed

            if not quiet:
                log.info(self._config.log_name, 'Shutter set to ' + ('auto' if enabled else 'closed'))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_gain(self, gain_index, quiet=False):
        """Set the preamplifier gain index"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            status = self.__set_gain_index(gain_index)
            if status == AndorStatus.DrvP1Invalid:
                return CommandStatus.InvalidGainIndex

            if status != AndorStatus.Success:
                return CommandStatus.Failed

            if not quiet:
                log.info(self._config.log_name, f'Gain index set to {gain_index}')

            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_horizontal_shift(self, shift_speed_index, quiet=False):
        """Set the horizontal shift speed index"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            status = self.__set_horizontal_shift_index(shift_speed_index)
            if status == AndorStatus.DrvP2Invalid:
                return CommandStatus.InvalidShiftSpeedIndex
            if status != AndorStatus.Success:
                return CommandStatus.Failed

            if not quiet:
                log.info(self._config.log_name, f'Readout speed index set to {shift_speed_index}')

            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_exposure(self, seconds, quiet=False):
        """Set the exposure time in seconds"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            if self.__set_exposure_time(seconds) != AndorStatus.Success:
                return CommandStatus.Failed

            if not quiet:
                log.info(self._config.log_name, f'Exposure time set to {seconds:.3f}s')

            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_exposure_delay(self, seconds, quiet=False):
        """Set the pre-exposure delay in seconds"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            self._exposure_delay = seconds

            if not quiet:
                log.info(self._config.log_name, f'Exposure delay set to {seconds:.3f}s')

            return CommandStatus.Succeeded

    def __set_readout_window(self, window, binning):
        """Set the exposure readout geometry."""
        with self._driver_lock:
            status = self._driver.SetImage(c_int(binning[0]), c_int(binning[1]),
                                           c_int(window[0]), c_int(window[1]),
                                           c_int(window[2]), c_int(window[3]))
            if status != AndorStatus.Success:
                region = f'[{window[0]}:{window[1]}, {window[2]}:{window[3]}]'
                print(f'failed to set geometry {region}({binning[0]}x{binning[1]})')
                return False

            self._window_bin = binning
            self._window_region = window

            # Round prescan and postscan up to nearest binned pixel to avoid bleeding
            prescan = int((self._config.overscan[0] + binning[0] - 1) / binning[0])
            postscan = int((self._config.overscan[1] + binning[0] - 1) / binning[0])

            # Work out how much pre/post scan columns are left in the requested window
            window_x = int((window[0] - 1) / binning[0])
            window_y = int((window[2] - 1) / binning[1])
            image_x1 = 1 + max(prescan, int((window[0] - 1) / binning[0])) - window_x
            image_x2 = min(int(self._ccd_width / binning[0]) - postscan, int(window[1] / binning[0])) - window_x
            image_y1 = 1 + int((window[2] - 1) / binning[1]) - window_y
            image_y2 = int(window[3] / binning[1]) - window_y

            # Window is completely in the overscan
            if image_x2 < image_x1:
                self._image_region = None
            else:
                self._image_region = [image_x1, image_x2, image_y1, image_y2]

        return True

    @Pyro4.expose
    def set_binning(self, bin_x, bin_y, quiet=False):
        """Sets the CCD readout binning (both x and y)"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            if not self.__set_readout_window(self._window_region, [bin_x, bin_y]):
                return CommandStatus.BinningIncompatibleWithWindow

            if not quiet:
                log.info(self._config.log_name, 'Binning set to ' + str(bin_x) + 'x' + str(bin_y))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_window(self, window, quiet=False):
        """Sets the CCD readout window in unbinned 1-indexed pixels"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            if window is None:
                window = [1, self._ccd_width, 1, self._ccd_height]

            elif len(window) == 4:
                if window[0] < 1 or window[0] > self._ccd_width:
                    return CommandStatus.WindowOutsideCCD
                if window[1] < window[0] or window[1] > self._ccd_width:
                    return CommandStatus.WindowOutsideCCD
                if window[2] < 1 or window[2] > self._ccd_height:
                    return CommandStatus.WindowOutsideCCD
                if window[3] < window[2] or window[3] > self._ccd_height:
                    return CommandStatus.WindowOutsideCCD
            else:
                return CommandStatus.Failed

            # Convert from 1-indexed to 0-indexed
            if not self.__set_readout_window(window, self._window_bin):
                return CommandStatus.WindowIncompatibleWithBinning

            if not quiet:
                region = f'[{window[0]}:{window[1]}, {window[2]}:{window[3]}]'
                log.info(self._config.log_name, 'Window set to ' + region)

            return CommandStatus.Succeeded

    @Pyro4.expose
    def shutdown(self):
        """Disconnects from the camera driver"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            # Complete the current exposure
            if self._acquisition_thread is not None:
                with self._driver_lock:
                    self._driver.AbortAcquisition()

                print('shutdown: waiting for acquisition to complete')
                self._stop_acquisition = True
                self._acquisition_thread.join()

            with self._driver_lock:
                print('shutdown: disconnecting driver')
                self._driver.ShutDown()
                self._driver = None

            log.info(self._config.log_name, 'Shutdown camera')
            return CommandStatus.Succeeded

    @Pyro4.expose
    def start_sequence(self, count, quiet=False):
        """Starts an exposure sequence with a set number of frames, or 0 to run until stopped"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            print('starting exposure sequence')
            count_msg = 'until stopped'
            if count == 1:
                count_msg = '1 frame'
            elif count > 1:
                count_msg = str(count) + ' frames'

            if not quiet:
                log.info(self._config.log_name, 'Starting exposure sequence (' + count_msg + ')')

            self._sequence_frame_limit = count
            self._sequence_frame_count = 0
            self._stop_acquisition = False
            self._acquisition_thread = threading.Thread(target=self.__run_exposure_sequence)
            self._acquisition_thread.daemon = False
            self._acquisition_thread.start()
            self._status = CameraStatus.Acquiring

            return CommandStatus.Succeeded

    @Pyro4.expose
    def stop_sequence(self):
        """Stops any active exposure sequence"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        if self._status == CameraStatus.Disabled:
            return CommandStatus.CameraNotInitialized

        # Note that the Waiting and Reading statuses are artificial
        # self._status stays as CameraStatus.Acquiring during both of these
        if self._status != CameraStatus.Acquiring:
            return CommandStatus.CameraNotAcquiring

        self._status = CameraStatus.Aborting
        log.info(self._config.log_name, 'Aborting exposure sequence')
        with self._driver_lock:
            self._driver.AbortAcquisition()

        self._sequence_frame_count = 0
        self._stop_acquisition = True

        with self._exposure_delay_condition:
            self._exposure_delay_condition.notify_all()

        return CommandStatus.Succeeded


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Camera control daemon')
    parser.add_argument('config', help='Path to configuration json file')
    args = parser.parse_args()
    c = Config(args.config)
    c.daemon.launch(CameraDaemon(c))
